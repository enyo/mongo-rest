// Generated by CoffeeScript 1.4.0
(function() {
  var MongoRest, exports, inflection, _,
    __hasProp = {}.hasOwnProperty;

  _ = require("underscore");

  inflection = require("inflection");

  MongoRest = (function() {

    MongoRest.prototype.defaultOptions = {
      urlRoot: "/",
      pathPrefix: "",
      pathSuffix: "",
      viewPrefix: "resource_",
      viewSuffix: "",
      viewDataNamePrefix: "",
      viewDataNameSuffix: "",
      camelizeJSONDataKeys: true,
      JSONDataNamePrefix: "",
      JSONDataNameSuffix: "",
      enableXhr: false,
      singleView: true
    };

    function MongoRest(app, options, dontRegisterRoutes) {
      var key, value, _ref, _ref1;
      this.app = app;
      this.options = {};
      _ref = this.defaultOptions;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        this.options[key] = (_ref1 = options != null ? options[key] : void 0) != null ? _ref1 : value;
      }
      this.resources = [];
      this.interceptors = {};
      if (!dontRegisterRoutes) {
        this.registerRoutes();
      }
    }

    MongoRest.prototype.registerRoutes = function() {
      this.app.all(this.options.urlRoot + ":resourceName", this.collection());
      this.app.get(this.options.urlRoot + ":resourceName", this.collectionGet());
      this.app.post(this.options.urlRoot + ":resourceName", this.collectionPost());
      this.app.all(this.options.urlRoot + ":resourceName/:id", this.entity());
      this.app.get(this.options.urlRoot + ":resourceName/:id", this.entityGet());
      this.app.put(this.options.urlRoot + ":resourceName/:id", this.entityPut());
      return this.app["delete"](this.options.urlRoot + ":resourceName/:id", this.entityDelete());
    };

    MongoRest.prototype.getPathName = function(resource) {
      var model, _ref, _ref1;
      model = resource.model;
      return ((_ref = this.options.pathPrefix) != null ? _ref : "") + (inflection.underscore(inflection.pluralize(model.modelName))).toLowerCase().replace("_", "-") + ((_ref1 = this.options.pathSuffix) != null ? _ref1 : "");
    };

    MongoRest.prototype.getView = function(resource, collection) {
      var model, view;
      if (collection == null) {
        collection = false;
      }
      model = resource.model;
      view = collection ? inflection.pluralize(model.modelName) : model.modelName;
      view = inflection.underscore(view).toLowerCase();
      return this.options.viewPrefix + view + this.options.viewSuffix;
    };

    MongoRest.prototype.getViewDataName = function(resource, collection) {
      var dataName, model;
      if (collection == null) {
        collection = false;
      }
      model = resource.model;
      dataName = collection ? inflection.pluralize(model.modelName) : model.modelName;
      dataName = dataName.charAt(0).toLowerCase() + dataName.slice(1);
      return this.options.viewDataNamePrefix + dataName + this.options.viewDataNameSuffix;
    };

    MongoRest.prototype.getJSONDataName = function(resource, collection) {
      var dataName, model;
      if (collection == null) {
        collection = false;
      }
      model = resource.model;
      dataName = collection ? inflection.pluralize(model.modelName) : model.modelName;
      dataName = dataName.charAt(0).toLowerCase() + dataName.slice(1);
      return this.options.JSONDataNamePrefix + dataName + this.options.JSONDataNameSuffix;
    };

    MongoRest.prototype.addResource = function(model, options) {
      var key, resource, value, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (options == null) {
        options = {};
      }
      resource = {
        model: model
      };
      if (options.sort != null) {
        resource.sort = options.sort;
      }
      _ref = this.options;
      for (key in _ref) {
        value = _ref[key];
        if (key !== "urlRoot") {
          resource[key] = (_ref1 = options[key]) != null ? _ref1 : value;
        }
      }
      resource.pathName = this.getPathName(resource);
      resource.entityView = (_ref2 = options.entityView) != null ? _ref2 : this.getView(resource);
      resource.collectionView = (_ref3 = options.collectionView) != null ? _ref3 : this.getView(resource, true);
      resource.entityViewDataName = (_ref4 = options.entityViewDataName) != null ? _ref4 : this.getViewDataName(resource);
      resource.collectionViewDataName = (_ref5 = options.collectionViewDataName) != null ? _ref5 : this.getViewDataName(resource, true);
      resource.entityJSONDataName = (_ref6 = options.entityJSONDataName) != null ? _ref6 : this.getJSONDataName(resource);
      resource.collectionJSONDataName = (_ref7 = options.collectionJSONDataName) != null ? _ref7 : this.getJSONDataName(resource, true);
      this.resources.push(resource);
      return resource;
    };

    MongoRest.prototype.getResource = function(pathOrModel) {
      var model, pathName, resource, _i, _len, _ref;
      if (typeof pathOrModel === "string") {
        pathName = pathOrModel;
      } else {
        model = pathOrModel;
      }
      _ref = this.resources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        resource = _ref[_i];
        if (resource.pathName === pathName || resource.model === model) {
          return resource;
        }
      }
      return null;
    };

    MongoRest.prototype.addInterceptor = function(model, eventOrEvents, handler) {
      var event, events, modelName, _i, _len, _results;
      if (!this.getResource(model)) {
        throw new Error("The resource " + model.modelName + " is not defined!");
      }
      modelName = model.modelName;
      events = [].concat(eventOrEvents);
      _results = [];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        event = events[_i];
        if (!this.interceptors[modelName]) {
          this.interceptors[modelName] = {};
        }
        if (!this.interceptors[modelName][event]) {
          this.interceptors[modelName][event] = [];
        }
        _results.push(this.interceptors[modelName][event].push(handler));
      }
      return _results;
    };

    MongoRest.prototype.invokeInterceptors = function(model, event, info, req, res, next, onFinish) {
      var checkIfFinished, done, error, finishedInterceptors, finishedInvoking, interceptorCount, modelName, realEvent, _ref;
      modelName = model.modelName;
      realEvent = event;
      if (event === "get-collection") {
        event = "get";
      }
      if (!((_ref = this.interceptors[modelName]) != null ? _ref[event] : void 0)) {
        return onFinish();
      }
      finishedInvoking = false;
      interceptorCount = 0;
      finishedInterceptors = 0;
      error = null;
      checkIfFinished = function() {
        if (!error && finishedInvoking && (finishedInterceptors === interceptorCount)) {
          return onFinish();
        }
      };
      done = function(err) {
        if (error) {
          return;
        }
        if (err) {
          error = err;
          return onFinish(err);
        } else {
          finishedInterceptors++;
          return checkIfFinished();
        }
      };
      _.all(this.interceptors[modelName][event], function(interceptor) {
        if (realEvent !== "get-collection") {
          interceptorCount++;
          interceptor(info, done, req, res, next);
        } else {
          _.all(info.docs, function(doc) {
            interceptorCount++;
            interceptor({
              doc: doc
            }, done, req, res, next);
            if (error) {
              return false;
            } else {
              return true;
            }
          });
        }
        if (error) {
          return false;
        } else {
          return true;
        }
      });
      finishedInvoking = true;
      return checkIfFinished();
    };

    MongoRest.prototype.getCollectionUrl = function(resource) {
      return this.options.urlRoot + resource.pathName;
    };

    MongoRest.prototype.getEntityUrl = function(resource, doc) {
      if (!resource.singleView) {
        return this.getCollectionUrl(resource);
      }
      return this.options.urlRoot + resource.pathName + "/" + doc._id;
    };

    MongoRest.prototype.flash = function(type, msg, req) {
      if (!req.xhr || !req.resource.enableXhr) {
        return req.flash(type, msg);
      }
    };

    MongoRest.prototype.renderError = function(err, redirectUrl, req, res, next) {
      var obj;
      if (req.resource.enableXhr && req.xhr) {
        obj = {
          error: err.message
        };
        redirectUrl && (obj.redirect = redirectUrl);
        return res.send(obj);
      } else {
        if (redirectUrl) {
          req.flash("error", err.message);
          return this.redirect(redirectUrl, req, res, next);
        } else {
          return next(err);
        }
      }
    };

    MongoRest.prototype._getPathName = function(model) {};

    MongoRest.prototype._serializeEntityName = function(key, resource) {};

    MongoRest.prototype._serializeKeyName = function(key, resource) {};

    /*
      Called to render a collection of docs
    
      @param  {Object}   err
      @param  {Object}   req
      @param  {Object}   res
      @param  {Function} next
      @api private
    */


    MongoRest.prototype.renderCollection = function(docs, req, res, next) {
      var data, doc, resource;
      resource = req.resource;
      data = {};
      if (resource.enableXhr && req.xhr) {
        data[resource.collectionJSONDataName] = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            _results.push(doc.toObject());
          }
          return _results;
        })();
        return res.send(data);
      } else {
        data[resource.collectionViewDataName] = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            doc = docs[_i];
            _results.push(doc.toObject());
          }
          return _results;
        })();
        data.site = req.params.resourceName + "-list";
        return res.render(resource.collectionView, data);
      }
    };

    MongoRest.prototype.renderEntity = function(doc, req, res, next) {
      var data, resource;
      resource = req.resource;
      data = {};
      if (resource.enableXhr && req.xhr) {
        data[resource.entityJSONDataName] = doc.toObject();
        return res.send(data);
      } else {
        data[resource.entityViewDataName] = doc.toObject();
        data.site = req.params.resourceName + "-show";
        return res.render(resource.entityView, data);
      }
    };

    MongoRest.prototype.redirect = function(address, req, res, next) {
      var resource;
      resource = req.resource;
      if (resource.enableXhr && req.xhr) {
        return res.send({
          redirect: address
        });
      } else {
        return res.redirect(address);
      }
    };

    MongoRest.prototype.collection = function() {
      var _this = this;
      return function(req, res, next) {
        req.resource = _this.getResource(req.params.resourceName);
        return next();
      };
    };

    MongoRest.prototype.collectionGet = function() {
      var _this = this;
      return function(req, res, next) {
        var query;
        if (!req.resource) {
          return next();
        }
        query = req.resource.model.find();
        if (req.resource.sort) {
          query.sort(req.resource.sort);
        }
        return query.exec(function(err, docs) {
          var finish, info;
          if (err) {
            return _this.renderError(err, null, req, res, next);
          }
          info = {
            docs: docs
          };
          finish = function() {
            return _this.renderCollection(docs, req, res, next);
          };
          return _this.invokeInterceptors(req.resource.model, "get-collection", info, req, res, next, finish);
        });
      };
    };

    MongoRest.prototype.collectionPost = function() {
      var _this = this;
      return function(req, res, next) {
        var error, info, redirectUrl, self;
        if (!req.resource) {
          return next();
        }
        self = _this;
        if (!req.body || !req.body.newResource) {
          throw new Error("Nothing submitted.");
        }
        info = {
          values: req.body.newResource
        };
        redirectUrl = self.getCollectionUrl(req.resource);
        error = function(err) {
          info.err = err;
          return self.invokeInterceptors(req.resource.model, "post.error", info, req, res, next, function(interceptorErr) {
            var finalErr;
            finalErr = interceptorErr || err;
            return self.renderError(new Error("Unable to insert the record: " + finalErr.message), redirectUrl, req, res, next);
          });
        };
        return _this.invokeInterceptors(req.resource.model, "post", info, req, res, next, function(err) {
          var doc;
          if (err) {
            return error(err);
          }
          doc = new req.resource.model(info.values);
          return doc.save(function(err) {
            if (err) {
              return error(err);
            }
            info.doc = doc;
            return self.invokeInterceptors(req.resource.model, "post.success", info, req, res, next, function(err) {
              if (err) {
                return error(err);
              }
              self.flash("success", "Successfully inserted the record.", req);
              if (req.resource.enableXhr && req.xhr) {
                return self.renderEntity(info.doc, req, res, next);
              } else {
                return self.redirect(redirectUrl, req, res, next);
              }
            });
          });
        });
      };
    };

    MongoRest.prototype.entity = function() {
      var _this = this;
      return function(req, res, next) {
        var self;
        self = _this;
        if (!(req.resource = _this.getResource(req.params.resourceName))) {
          next();
          return;
        }
        return req.resource.model.findOne({
          _id: req.params.id
        }, function(err, doc) {
          if (err) {
            self.renderError(err, self.getCollectionUrl(req.resource), req, res, next);
            return;
          }
          req.doc = doc;
          return next();
        });
      };
    };

    MongoRest.prototype.entityGet = function() {
      var _this = this;
      return function(req, res, next) {
        var error, info, onFinish, self;
        if (!req.resource) {
          return next();
        }
        self = _this;
        info = {
          doc: req.doc
        };
        error = function(err) {
          info.err = err;
          return self.invokeInterceptors(req.resource.model, "get.error", info, req, res, next, function(interceptorErr) {
            var finalErr;
            finalErr = interceptorErr || err;
            return self.renderError(new Error("Unable to get the record: " + finalErr.message), null, req, res, next);
          });
        };
        onFinish = function(err) {
          if (err) {
            error(err);
            return;
          }
          return self.renderEntity(info.doc, req, res, next);
        };
        return _this.invokeInterceptors(req.resource.model, "get", info, req, res, next, onFinish);
      };
    };

    /*
      Updates a resource with the given parameters.
    
      It invokes the `put` and `put.error` or `put.success` interceptors. The info object consists of:
    
      - `values` The new values that are about to be inserted. You can set a new object and it will be used.
      - `doc` The document that is about to be updated.
      - `err` The exception, only for error interceptors.
    
      @return {Function} The function to use as route
    */


    MongoRest.prototype.entityPut = function() {
      var _this = this;
      return function(req, res, next) {
        var error, info, redirectUrl, self;
        if (!req.resource) {
          return next();
        }
        self = _this;
        if (!req.body || !req.body.newResource) {
          throw new Error("Nothing submitted.");
        }
        info = {
          doc: req.doc,
          values: req.body.newResource
        };
        redirectUrl = self.getEntityUrl(req.resource, req.doc);
        error = function(err) {
          info.err = err;
          return self.invokeInterceptors(req.resource.model, "put.error", info, req, res, next, function(interceptorErr) {
            var finalErr;
            finalErr = interceptorErr || err;
            return self.renderError(new Error("Unable to save the record: " + finalErr.message), redirectUrl, req, res, next);
          });
        };
        return _this.invokeInterceptors(req.resource.model, "put", info, req, res, next, function(err) {
          if (err != null) {
            return error(err);
          }
          _.each(info.values, function(value, name) {
            return req.doc[name] = value;
          });
          return req.doc.save(function(err) {
            if (err != null) {
              return error(err);
            }
            return self.invokeInterceptors(req.resource.model, "put.success", info, req, res, next, function(err) {
              if (err != null) {
                return error(err);
              }
              self.flash("success", "Successfully updated the record.", req);
              return self.redirect(redirectUrl, req, res, next);
            });
          });
        });
      };
    };

    /*
      Deletes the resource.
    
      It invokes the `delete` and `delete.error` or `delete.success` interceptors. The info object consists of:
    
      - `doc` The document that is about to be deleted.
      - `err` The exception, only for error interceptors.
    
      @return {Function} The function to use as route
    */


    MongoRest.prototype.entityDelete = function() {
      var _this = this;
      return function(req, res, next) {
        var error, info, redirectUrl, self;
        if (!req.resource) {
          next();
          return;
        }
        info = {
          doc: req.doc
        };
        self = _this;
        redirectUrl = self.getCollectionUrl(req.resource);
        error = function(err) {
          info.err = err;
          return self.invokeInterceptors(req.resource.model, "delete.error", info, req, res, next, function(interceptorErr) {
            var finalErr;
            finalErr = interceptorErr || err;
            return self.renderError(new Error("Unable to delete the record: " + finalErr.message), redirectUrl, req, res, next);
          });
        };
        return _this.invokeInterceptors(req.resource.model, "delete", info, req, res, next, function(err) {
          if (err) {
            error(err);
            return;
          }
          return req.doc.remove(function(err) {
            if (err) {
              error(err);
              return;
            }
            return self.invokeInterceptors(req.resource.model, "delete.success", info, req, res, next, function(err) {
              if (err) {
                error(err);
                return;
              }
              self.flash("success", "Successfully deleted the record.", req);
              return self.redirect(redirectUrl, req, res, next);
            });
          });
        });
      };
    };

    return MongoRest;

  })();

  module.exports = exports = MongoRest;

}).call(this);
