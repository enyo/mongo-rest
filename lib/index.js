// Generated by CoffeeScript 1.4.0
(function() {
  var MongoRest, exports, _,
    __hasProp = {}.hasOwnProperty;

  _ = require("underscore");

  MongoRest = (function() {

    MongoRest.prototype.defaultOptions = {
      urlPath: "/",
      entityViewTemplate: "resource_{{singularName}}",
      collectionViewTemplate: "resource_{{pluralName}}",
      enableXhr: false,
      singleView: true
    };

    function MongoRest(app, options, dontRegisterRoutes) {
      var key, value, _ref;
      this.app = app;
      this.options = {};
      _ref = this.defaultOptions;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        this.options[key] = (options != null ? options[key] : void 0) != null ? options[key] : value;
      }
      this.resources = [];
      this.interceptors = {};
      if (!dontRegisterRoutes) {
        this.registerRoutes();
      }
    }

    MongoRest.prototype.registerRoutes = function() {
      /*
          Accessing multiple resources
      */
      this.app.all(this.options.urlPath + ":resourceName", this.collection());
      this.app.get(this.options.urlPath + ":resourceName", this.collectionGet());
      this.app.post(this.options.urlPath + ":resourceName", this.collectionPost());
      /*
          Accessing single entities
      */

      this.app.all(this.options.urlPath + ":resourceName/:id", this.entity());
      this.app.get(this.options.urlPath + ":resourceName/:id", this.entityGet());
      this.app.put(this.options.urlPath + ":resourceName/:id", this.entityPut());
      return this.app["delete"](this.options.urlPath + ":resourceName/:id", this.entityDelete());
    };

    MongoRest.prototype.addResource = function(singularName, model, pluralName, defaultSort) {
      var resource;
      pluralName = pluralName || singularName + "s";
      if (pluralName === singularName) {
        throw new Exception("The singular and plural name have to be different.");
      }
      resource = {
        singularName: singularName,
        pluralName: pluralName,
        model: model
      };
      if (defaultSort) {
        resource.sort = defaultSort;
      }
      return this.resources.push(resource);
    };

    MongoRest.prototype.getResource = function(name) {
      return _.find(this.resources, function(resource) {
        return resource.pluralName === name || resource.singularName === name;
      });
    };

    MongoRest.prototype.addInterceptor = function(resourceName, event, handler) {
      var interceptors, resource;
      resource = this.getResource(resourceName);
      interceptors = this.interceptors;
      if (!resource) {
        throw new Error("The resource " + resourceName + " is not defined!");
      }
      resourceName = resource.singularName;
      if (!_.isArray(event)) {
        event = [event];
      }
      return _.each(event, function(event) {
        if (!interceptors[resourceName]) {
          interceptors[resourceName] = {};
        }
        if (!interceptors[resourceName][event]) {
          interceptors[resourceName][event] = [];
        }
        return interceptors[resourceName][event].push(handler);
      });
    };

    MongoRest.prototype.invokeInterceptors = function(singularResourceName, event, info, req, res, next, onFinish) {
      var checkIfFinished, done, error, finishedInterceptors, finishedInvoking, interceptorCount, interceptors, realEvent;
      interceptors = this.interceptors;
      realEvent = event;
      if (event === "get-collection") {
        event = "get";
      }
      if (!interceptors[singularResourceName] || !interceptors[singularResourceName][event]) {
        onFinish();
        return;
      }
      finishedInvoking = false;
      interceptorCount = 0;
      finishedInterceptors = 0;
      error = null;
      checkIfFinished = function() {
        if (!error && finishedInvoking && (finishedInterceptors === interceptorCount)) {
          return onFinish();
        }
      };
      done = function(err) {
        if (error) {
          return;
        }
        if (err) {
          error = err;
          return onFinish(err);
        } else {
          finishedInterceptors++;
          return checkIfFinished();
        }
      };
      _.all(interceptors[singularResourceName][event], function(interceptor) {
        if (realEvent !== "get-collection") {
          interceptorCount++;
          interceptor(info, done, req, res, next);
        } else {
          _.all(info.docs, function(doc) {
            interceptorCount++;
            interceptor({
              doc: doc
            }, done, req, res, next);
            if (error) {
              return false;
            } else {
              return true;
            }
          });
        }
        if (error) {
          return false;
        } else {
          return true;
        }
      });
      finishedInvoking = true;
      return checkIfFinished();
    };

    /*
      Parses a view template by replacing singular and plural names.
    
      @param  {String} template
      @param  {Object} resource
      @return {String}
    */


    MongoRest.prototype.parseViewTemplate = function(template, resource) {
      return template.replace("{{singularName}}", resource.singularName).replace("{{pluralName}}", resource.pluralName);
    };

    /*
      Returns the url for a resource collection
    
      @param  {Object} resource
      @return {String}
    */


    MongoRest.prototype.getCollectionUrl = function(resource) {
      return this.options.urlPath + resource.pluralName;
    };

    /*
      Returns the url for a specific doc
    
      @param  {Object} resource
      @param  {Doc} doc
      @return {String}
    */


    MongoRest.prototype.getEntityUrl = function(resource, doc) {
      if (this.options.singleView) {
        return this.options.urlPath + resource.singularName + "/" + doc._id;
      } else {
        return this.getCollectionUrl(resource);
      }
    };

    /*
      This only actually flashes if this is not an XHR.
    
      Forwards to `req.flash()`
    
      @param  {String} type
      @param  {String} msg
      @param  {Req} req
    */


    MongoRest.prototype.flash = function(type, msg, req) {
      if (!req.xhr || !this.options.enableXhr) {
        return req.flash(type, msg);
      }
    };

    /*
      Called when there was an error.
    
      If there is a redirectUrl (and not XHR), it will redirect there.
    
      Either calles next with the error or returns it as XMLHttp.
    
      @param  {Error}   err
      @param  {String}   Redirect url. If set it will redirect, otherwise call next() with error.
      @param  {Object}   req
      @param  {Object}   res
      @param  {Function} next
      @api private
    */


    MongoRest.prototype.renderError = function(err, redirectUrl, req, res, next) {
      var obj;
      if (this.options.enableXhr && req.xhr) {
        obj = {
          error: err.message
        };
        redirectUrl && (obj.redirect = redirectUrl);
        return res.send(obj);
      } else {
        if (redirectUrl) {
          req.flash("error", err.message);
          return this.redirect(redirectUrl, req, res, next);
        } else {
          return next(err);
        }
      }
    };

    /*
      Called to render a collection of docs
    
      @param  {Object}   err
      @param  {Object}   req
      @param  {Object}   res
      @param  {Function} next
      @api private
    */


    MongoRest.prototype.renderCollection = function(docs, req, res, next) {
      if (this.options.enableXhr && req.xhr) {
        return res.send({
          docs: docs
        });
      } else {
        return res.render(this.parseViewTemplate(this.options.collectionViewTemplate, req.resource), {
          docs: docs,
          site: req.params.resourceName + "-list"
        });
      }
    };

    /*
      Called to render a collection of docs
    
      @param  {Object}   err
      @param  {Object}   req
      @param  {Object}   res
      @param  {Function} next
      @api private
    */


    MongoRest.prototype.renderEntity = function(doc, req, res, next) {
      if (this.options.enableXhr && req.xhr) {
        return res.send({
          doc: doc
        });
      } else {
        return res.render(this.parseViewTemplate(this.options.entityViewTemplate, req.resource), {
          doc: doc,
          site: req.params.resourceName + "-show"
        });
      }
    };

    /*
      Called to redirect
    
      @param  {String}   address
      @param  {Object}   req
      @param  {Object}   res
      @param  {Function} next
      @api private
    */


    MongoRest.prototype.redirect = function(address, req, res, next) {
      if (this.options.enableXhr && req.xhr) {
        return res.send({
          redirect: address
        });
      } else {
        return res.redirect(address);
      }
    };

    /*
      All entities rest functions have to go through this first.
      This function makes sure the resource is actually served, and
      puts the right model in the req object
    
      @return {Function} The function to use as route
    */


    MongoRest.prototype.collection = function() {
      return _.bind((function(req, res, next) {
        if (!(req.resource = this.getResource(req.params.resourceName))) {
          next();
          return;
        }
        return next();
      }), this);
    };

    /*
      Renders a view with the list of all docs.
    
      @return {Function} The function to use as route
    */


    MongoRest.prototype.collectionGet = function() {
      return _.bind((function(req, res, next) {
        var query, self;
        if (!req.resource) {
          next();
          return;
        }
        self = this;
        query = req.resource.model.find();
        if (req.resource.sort) {
          _.each(req.resource.sort, function(sort) {
            return query.sort(sort[0], sort[1]);
          });
        }
        return query.exec(function(err, docs) {
          var finish, info;
          if (err) {
            self.renderError(err, null, req, res, next);
          } else {
            info = {
              docs: docs
            };
            finish = function() {
              return self.renderCollection(docs, req, res, next);
            };
            return self.invokeInterceptors(req.resource.singularName, "get-collection", info, req, res, next, finish);
          }
        });
      }), this);
    };

    /*
      Handles the new values, and redirects to the list.
    
      It invokes the `post` interceptors. The info object consists of:
    
      - `values` The new values that are about to be inserted. You can set a new object and it will be used.
      - `doc` Only for `success` or `error` interceptors. The document that was just inserted.
      - `err` The exception, only for error interceptors.
    
      @return {Function} The function to use as route
    */


    MongoRest.prototype.collectionPost = function() {
      return _.bind((function(req, res, next) {
        var error, info, redirectUrl, self;
        if (!req.resource) {
          next();
          return;
        }
        self = this;
        if (!req.body || !req.body.newResource) {
          throw new Error("Nothing submitted.");
        }
        info = {
          values: req.body.newResource
        };
        redirectUrl = self.getCollectionUrl(req.resource);
        error = function(err) {
          info.err = err;
          return self.invokeInterceptors(req.resource.singularName, "post.error", info, req, res, next, function(interceptorErr) {
            var finalErr;
            finalErr = interceptorErr || err;
            return self.renderError(new Error("Unable to insert the record: " + finalErr.message), redirectUrl, req, res, next);
          });
        };
        return this.invokeInterceptors(req.resource.singularName, "post", info, req, res, next, function(err) {
          var doc;
          if (err) {
            error(err);
            return;
          }
          doc = new req.resource.model(info.values);
          return doc.save(function(err) {
            if (err) {
              error(err);
              return;
            }
            info.doc = doc;
            return self.invokeInterceptors(req.resource.singularName, "post.success", info, req, res, next, function(err) {
              if (err) {
                error(err);
                return;
              }
              self.flash("success", "Successfully inserted the record.", req);
              if (self.options.enableXhr && req.xhr) {
                return self.renderEntity(info.doc, req, res, next);
              } else {
                return self.redirect(redirectUrl, req, res, next);
              }
            });
          });
        });
      }), this);
    };

    /*
      All entity rest functions have to go through this first.
      This function is in charge of loading the entity.
    
      @return {Function} The function to use as route
    */


    MongoRest.prototype.entity = function() {
      return _.bind((function(req, res, next) {
        var self;
        self = this;
        if (!(req.resource = this.getResource(req.params.resourceName))) {
          next();
          return;
        }
        return req.resource.model.findOne({
          _id: req.params.id
        }, function(err, doc) {
          if (err) {
            self.renderError(err, self.getCollectionUrl(req.resource), req, res, next);
            return;
          }
          req.doc = doc;
          return next();
        });
      }), this);
    };

    /*
      Gets a single entity
    
      @return {Function} The function to use as route
    */


    MongoRest.prototype.entityGet = function() {
      return _.bind((function(req, res, next) {
        var error, info, onFinish, self;
        if (!req.resource) {
          next();
          return;
        }
        self = this;
        info = {
          doc: req.doc
        };
        error = function(err) {
          info.err = err;
          return self.invokeInterceptors(req.resource.singularName, "get.error", info, req, res, next, function(interceptorErr) {
            var finalErr;
            finalErr = interceptorErr || err;
            return self.renderError(new Error("Unable to get the record: " + finalErr.message), null, req, res, next);
          });
        };
        onFinish = function(err) {
          if (err) {
            error(err);
            return;
          }
          return self.renderEntity(info.doc, req, res, next);
        };
        return this.invokeInterceptors(req.resource.singularName, "get", info, req, res, next, onFinish);
      }), this);
    };

    /*
      Updates a resource with the given parameters.
    
      It invokes the `put` and `put.error` or `put.success` interceptors. The info object consists of:
    
      - `values` The new values that are about to be inserted. You can set a new object and it will be used.
      - `doc` The document that is about to be updated.
      - `err` The exception, only for error interceptors.
    
      @return {Function} The function to use as route
    */


    MongoRest.prototype.entityPut = function() {
      return _.bind((function(req, res, next) {
        var error, info, redirectUrl, self;
        if (!req.resource) {
          next();
          return;
        }
        self = this;
        if (!req.body || !req.body.newResource) {
          throw new Error("Nothing submitted.");
        }
        info = {
          doc: req.doc,
          values: req.body.newResource
        };
        redirectUrl = self.getEntityUrl(req.resource, req.doc);
        error = function(err) {
          info.err = err;
          return self.invokeInterceptors(req.resource.singularName, "put.error", info, req, res, next, function(interceptorErr) {
            var finalErr;
            finalErr = interceptorErr || err;
            return self.renderError(new Error("Unable to save the record: " + finalErr.message), redirectUrl, req, res, next);
          });
        };
        return this.invokeInterceptors(req.resource.singularName, "put", info, req, res, next, function(err) {
          if (err) {
            error(err);
            return;
          }
          _.each(info.values, function(value, name) {
            return req.doc[name] = value;
          });
          return req.doc.save(function(err) {
            if (err) {
              error(err);
              return;
            }
            return self.invokeInterceptors(req.resource.singularName, "put.success", info, req, res, next, function(err) {
              if (err) {
                error(err);
                return;
              }
              self.flash("success", "Successfully updated the record.", req);
              return self.redirect(redirectUrl, req, res, next);
            });
          });
        });
      }), this);
    };

    /*
      Deletes the resource.
    
      It invokes the `delete` and `delete.error` or `delete.success` interceptors. The info object consists of:
    
      - `doc` The document that is about to be deleted.
      - `err` The exception, only for error interceptors.
    
      @return {Function} The function to use as route
    */


    MongoRest.prototype.entityDelete = function() {
      return _.bind((function(req, res, next) {
        var error, info, redirectUrl, self;
        if (!req.resource) {
          next();
          return;
        }
        info = {
          doc: req.doc
        };
        self = this;
        redirectUrl = self.getCollectionUrl(req.resource);
        error = function(err) {
          info.err = err;
          return self.invokeInterceptors(req.resource.singularName, "delete.error", info, req, res, next, function(interceptorErr) {
            var finalErr;
            finalErr = interceptorErr || err;
            return self.renderError(new Error("Unable to delete the record: " + finalErr.message), redirectUrl, req, res, next);
          });
        };
        return this.invokeInterceptors(req.resource.singularName, "delete", info, req, res, next, function(err) {
          if (err) {
            error(err);
            return;
          }
          return req.doc.remove(function(err) {
            if (err) {
              error(err);
              return;
            }
            return self.invokeInterceptors(req.resource.singularName, "delete.success", info, req, res, next, function(err) {
              if (err) {
                error(err);
                return;
              }
              self.flash("success", "Successfully deleted the record.", req);
              return self.redirect(redirectUrl, req, res, next);
            });
          });
        });
      }), this);
    };

    return MongoRest;

  })();

  module.exports = exports = MongoRest;

}).call(this);
